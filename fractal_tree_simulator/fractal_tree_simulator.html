<div id="fractal-tree-app">
    <style>
        #fractal-tree-app {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 10px;
            max-width: 800px;
            box-sizing: border-box;
        }
        #fractal-tree-app.dark {
            background: #111;
            color: #eee;
        }
        #fractal-tree-app .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        #fractal-tree-app canvas {
            background: #f8f8f8;
            border: 1px solid #ccc;
            width: 100%;
            max-width: 600px;
            height: auto;
        }
        #fractal-tree-app.dark canvas {
            background: #222;
            border-color: #555;
        }
        #fractal-tree-app .controls {
            flex: 1;
            min-width: 200px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #fractal-tree-app label {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        #fractal-tree-app input[type="range"] {
            flex: 1;
        }
        #fractal-tree-app button {
            padding: 6px 10px;
            border: none;
            background: #4676D7;
            color: white;
            border-radius: 4px;
            cursor: pointer;
        }
        #fractal-tree-app button:hover {
            background: #365cab;
        }
        #fractal-tree-app .hero{padding:40px 20px;text-align:center;background:linear-gradient(to top,#333,#666);color:#fff;}
        #fractal-tree-app .subtitle{font-style:italic;font-size:0.9em;}
        #fractal-tree-app .section{margin-top:20px;line-height:1.5;}
        #fractal-tree-app .link{color:#4676D7;text-decoration:none;}

    </style>
    <header class="hero">
        <h1>가지가 갈라지는 순간</h1>
        <p class="subtitle">갈라짐은 상처가 아니라 새로운 방향</p>
    </header>
    <section class="section">
        <h2>L-System 한입 요약</h2>
        <p>알파벳, 공리, 생산규칙을 재귀적으로 적용해 복잡한 패턴을 만들어냅니다.</p>
        <p><code>F → FF-[-F+F+F]+[+F-F-F]</code></p>
        <p><a class="link" href="https://thecodingtrain.com" target="_blank">The Coding Train</a></p>
    </section>
    <div class="container">
        <canvas id="tree-canvas" width="600" height="500"></canvas>
        <div class="controls">
            <label>📐 Angle <span id="angle-val">25</span>
                <input id="angle" type="range" min="0" max="90" step="1" value="25">
            </label>
            <label>🌿 Length <span id="len-val">0.67</span>
                <input id="lenScale" type="range" min="0.5" max="0.8" step="0.01" value="0.67">
            </label>
            <label>💨 Wind
                <input id="wind" type="range" min="0" max="2" step="0.1" value="0">
            </label>
            <div style="display:flex; gap:10px; flex-wrap:wrap;">
                <button id="grow">Grow</button>
                <button id="reset">Reset</button>
                <button id="export">Export SVG</button>
                <button id="toggle-theme">Night</button>
            </div>
        </div>
    </div>
    <section class="section">
        <h2>선택의 각도 22.5°</h2>
        <p>작은 각도 차이가 시간이 흐르며 큰 변화를 만듭니다. 올해 나를 성장시킬 1°는 어디일까요?</p>
    </section>
    <script>
        (function(){
            const canvas = document.getElementById('tree-canvas');
            const ctx = canvas.getContext('2d');
            const angleInput = document.getElementById('angle');
            const lenInput = document.getElementById('lenScale');
            const windInput = document.getElementById('wind');
            const angleVal = document.getElementById('angle-val');
            const lenVal = document.getElementById('len-val');
            let angleDeg = parseFloat(angleInput.value);
            let lenScale = parseFloat(lenInput.value);
            let wind = parseFloat(windInput.value);
            let axiom = 'F';
            let sentence = axiom;
            let generation = 0;
            const rules = [{a:'F', b:'FF-[-F+F+F]+[+F-F-F]'}];

            function generate(){
                let next = '';
                for (let ch of sentence){
                    let replaced = ch;
                    for (let r of rules){
                        if (ch === r.a){
                            replaced = r.b;
                            break;
                        }
                    }
                    next += replaced;
                }
                sentence = next;
                generation++;
            }

            function randWind(){
                return (Math.random() - 0.5) * wind;
            }

            function draw(){
                ctx.save();
                if(document.getElementById('fractal-tree-app').classList.contains('dark')){
                    ctx.fillStyle = '#111';
                    ctx.strokeStyle = '#eee';
                }else{
                    ctx.fillStyle = '#fff';
                    ctx.strokeStyle = '#333';
                }
                ctx.fillRect(0,0,canvas.width,canvas.height);
                ctx.translate(canvas.width/2, canvas.height);
                drawLSystem(sentence, canvas.height/4);
                ctx.restore();
            }

            function drawLSystem(seq, len){
                // custom stack to avoid canvas state limits
                const stack = [];
                let x = 0;
                let y = 0;
                let angle = -Math.PI/2; // start pointing up
                ctx.beginPath();
                ctx.moveTo(x, y);
                for(let ch of seq){
                    switch(ch){
                        case 'F':
                            x += Math.cos(angle) * len;
                            y += Math.sin(angle) * len;
                            ctx.lineTo(x, y);
                            break;
                        case '+':
                            angle += (angleDeg + randWind()) * Math.PI/180;
                            break;
                        case '-':
                            angle -= (angleDeg + randWind()) * Math.PI/180;
                            break;
                        case '[':
                            stack.push({x, y, angle, len});
                            len *= lenScale;
                            break;
                        case ']':
                            ({x, y, angle, len} = stack.pop());
                            ctx.moveTo(x, y);
                            break;
                    }
                }
                ctx.stroke();
            }

            function update(){
                angleDeg = parseFloat(angleInput.value);
                lenScale = parseFloat(lenInput.value);
                wind = parseFloat(windInput.value);
                angleVal.textContent = angleDeg;
                lenVal.textContent = lenScale;
                draw();
            }

            angleInput.addEventListener('input', update);
            lenInput.addEventListener('input', update);
            windInput.addEventListener('input', update);
            document.getElementById('grow').addEventListener('click', function(){
                generate();
                draw();
            });
            document.getElementById('reset').addEventListener('click', function(){
                sentence = axiom;
                generation = 0;
                draw();
            });
            document.getElementById('export').addEventListener('click', exportSVG);
            function exportSVG(){
                let len = canvas.height/4;
                let x = canvas.width/2;
                let y = canvas.height;
                let angle = -Math.PI/2;
                const stack = [];
                let d = `M${x} ${y}`;
                for(const ch of sentence){
                    switch(ch){
                        case "F":
                            x += Math.cos(angle) * len;
                            y += Math.sin(angle) * len;
                            d += `L${x} ${y}`;
                            break;
                        case "+":
                            angle += angleDeg * Math.PI/180;
                            break;
                        case "-":
                            angle -= angleDeg * Math.PI/180;
                            break;
                        case "[":
                            stack.push({x,y,angle,len});
                            len *= lenScale;
                            break;
                        case "]":
                            ({x,y,angle,len} = stack.pop());
                            d += `M${x} ${y}`;
                            break;
                    }
                }
                const stroke = document.getElementById("fractal-tree-app").classList.contains("dark") ? "#eee" : "#333";
                const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${canvas.width}" height="${canvas.height}"><path d="${d}" fill="none" stroke="${stroke}"/></svg>`;
                const blob = new Blob([svg], {type:"image/svg+xml"});
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "tree.svg";
                a.click();
                URL.revokeObjectURL(url);
            }
            document.getElementById('toggle-theme').addEventListener('click', function(){
                const app = document.getElementById('fractal-tree-app');
                app.classList.toggle('dark');
                draw();
            });

            draw();
        })();
    </script>
</div>
