
<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Ant–Nitrogen Cycle Simulator (v19 – richer visuals)</title>
<style>
  body{margin:0;padding:0;display:flex;justify-content:center;background:#fafafa;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;}
  #wrapper{padding:10px;max-width:960px;width:100%;box-sizing:border-box;text-align:center;}
  canvas{display:block;margin:0 auto;background:#f8f9fa;border-radius:8px;box-shadow:0 0 10px rgba(0,0,0,0.15);width:100%;max-width:960px;}
  .controls{margin:10px auto;text-align:center;width:100%;}
  #legend{font-size:14px;margin:0 auto 10px auto;max-width:880px;width:100%;}
  #legend svg{width:12px;height:12px;vertical-align:middle;margin-left:10px;}
  #legend svg:first-child{margin-left:0;}
</style>
</head>
<body>
<div id="wrapper">

  <!-- UI -->
  <div class="controls">
    
<label>개미 이동 속도: <span id="speedLabel">1</span>x</label>
<input id="antSpeed" type="range" min="0.2" max="2" step="0.1" value="1"/>

    <label>개미 수: <span id="antCountLabel">100</span></label>
    <input id="antCount" type="range" min="10" max="500" value="100"/>
    <br/>
    <label>양분 패치 크기: <span id="nutrientAmountLabel">50</span></label>
    <input id="nutrientAmount" type="range" min="10" max="500" value="50"/>
    <br/>
    <label>양분 생성주기(초): <span id="nutrientIntervalLabel">5</span></label>
    <input id="nutrientInterval" type="range" min="1" max="20" value="5"/>
  </div>

  <div class="controls">
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
    <button id="resetBtn">Reset</button>
  </div>

</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>

<script>
/* CONFIG */
const GRID=30, TREE_LIFE=800, N_TH=3, O_TH=2, AGE_TH=120, BLOOM_P=0.3;
const BLOSSOM_COLORS=['#ffb6c1','#ffc0cb','#ffd1dc','#ffa6c9','#ffccd5'];
const MAX_TREE_H=3, NUTRIENT_HIGHLIGHT_TH=4;

/* STATE */
let CELL,W,H,NX,NY,soil=[],ants=[],foods=[];
let CELL_BG_COLOR = '#816C30';
let BACKGROUND_CHANGED = false;
const CAND_SHADE_COLOR = '#816C30';
    nutrientSize=50,nutrientInterval=5*60,nextPatch=0,running=true;

/* CLASSES */
class SoilCell{
  constructor(x,y){this.x=x;this.y=y;this.org=0;this.nit=0;this.plant=0;this.bloom=0;this.age=0;this.tree=false;this.nest=false;}
  update(){
    const dn=this.org*0.02; this.nit+=dn; this.org-=dn;
    const up=this.nit*0.01; this.plant+=up*5; this.nit-=up;
    const dc=this.plant*0.005; this.plant-=dc; this.nit+=dc;

    if(!this.nest && this.plant<=1){
      this.bloom=((this.nit/N_TH)+(this.org/O_TH))*0.5;
      if(this.bloom>=1) this.age++; else this.age=0;
      if(this.age>AGE_TH && random()<BLOOM_P && !this.tree){
        this.plant=2; this.tree=true;
      }
    }else{this.bloom=0; this.age=0;}

    if(this.plant>1){
      this.age++;
      if(this.age>TREE_LIFE){this.nit+=this.plant; this.plant=0; this.age=0; this.tree=false;}
      else{this.plant=min(this.plant+0.03,CELL*MAX_TREE_H);}
    }
  }
  drawGround(){
    const x=this.x*CELL,y=this.y*CELL;
    noStroke(); fill(CELL_BG_COLOR); rect(x,y,CELL,CELL);
    // shade candidate 3x3 area for potential tree growth
    let cand=false;
    for(let dy=-1;dy<=1&&!cand;dy++){
      for(let dx=-1;dx<=1;dx++){
        const nx=this.x+dx, ny=this.y+dy;
        if(nx>=0&&nx<NX&&ny>=0&&ny<NY){
          const n=soil[ny][nx];
          if(!n.tree && n.bloom>BLOOM_P*0.6){ cand=true; break; }
        }
      }
    }
    if(cand && !BACKGROUND_CHANGED){
  BACKGROUND_CHANGED = true;
  CELL_BG_COLOR = CAND_SHADE_COLOR;
}
if(cand){
  push();
  for (let i = 0; i < 3; i++) {
    const alpha = 30 - i * 10;
    fill(129,108,48, alpha);
    rect(x - i, y - i, CELL + 2 * i, CELL + 2 * i);
  }
  pop();
}
}
  drawPlant(){ if(this.plant>1) drawTree(this.x,this.y,this.plant); }
}



class Ant{
  constructor(x,y){
    this.x=x;
    this.y=y;
    this.angle=0;   // 라디안 각도
  }
  update(){
    // 4방향 랜덤 이동
    const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
    const [dx,dy] = random(dirs);
    // 격자 경계 체크
    if(this.x+dx>=0 && this.x+dx<NX) this.x += dx;
    if(this.y+dy>=0 && this.y+dy<NY) this.y += dy;
    // 이동한 방향에 맞춰 각도 갱신
    this.angle = atan2(dy, dx);
  }
  
  draw(){
    push();
    translate(this.x*CELL + CELL/2, this.y*CELL + CELL/2);
    rotate(this.angle);
    noStroke();

    fill(140, 128, 64);
    arc(0, 0, CELL * 0.8, CELL * 0.8, radians(45), radians(315), PIE);
    pop();
  }
}


class Food {
  constructor(x, y, amount = 1) {
    this.x = x;
    this.y = y;
    this.amount = amount;
  }
  draw() {
    push();
    translate(this.x * CELL + CELL / 2, this.y * CELL + CELL / 2);
    noStroke();
    fill(138, 43, 226, 220); // bright obsidian purple

    beginShape();
    vertex(0, -CELL * 0.9);
    vertex(CELL * 0.9, 0);
    vertex(0, CELL * 0.9);
    vertex(-CELL * 0.9, 0);
    endShape(CLOSE);
    pop();
  }
}


/* TREE & BLOSSOM */

function drawTree(cx,cy,h){
  const height = min(h, CELL*MAX_TREE_H);
  push();
  translate(cx*CELL + CELL/2, cy*CELL + CELL);
  stroke(139,69,19); strokeWeight(6);

  // trunk
  line(0, 0, 0, -height);

  // radial branches
  for (let ang = 0; ang < TWO_PI; ang += PI / 3) {
    const len = height * 0.6;
    const bx = len * cos(ang);
    const by = -height + len * sin(ang);
    line(0, -height, bx, by);
  }

  noStroke();

  // deterministic pseudo‑random blossoms without affecting global random()
  const fract = v => v - Math.floor(v);
  for (let i = 0; i < 25; i++) {
    const r1 = fract(Math.sin((i + 1) * 12.9898 + cx * 78.233 + cy * 37.719) * 43758.5453);
    const ang = TWO_PI * r1;
    const r2 = fract(Math.sin((i + 1) * 93.9898 + cx * 11.233 + cy * 7.719) * 43758.5453);
    const rad = map(r2, 0, 1, height * 0.2, height * 0.75);
    const colIndex = Math.floor(r1 * BLOSSOM_COLORS.length) % BLOSSOM_COLORS.length;
    const col = BLOSSOM_COLORS[colIndex];
    drawBlossom(cos(ang) * rad, sin(ang) * rad - height, height * 0.28, col);
  }
  pop();
}


function drawBlossom(x, y, size, col){
  push();
  translate(x, y);
  fill(col + 'AA');
  noStroke();
  const petals = 5;
  for (let i = 0; i < petals; i++){
    const ang = TWO_PI * i / petals;
    ellipse(cos(ang) * size * 0.6, sin(ang) * size * 0.6, size, size * 0.55);
  }
  pop();
}

/* WORLD */
function initWorld(count){
  CELL=floor(min(window.innerWidth*0.9,920)/GRID); W=CELL*GRID; H=W;
  resizeCanvas ? resizeCanvas(W,H) : createCanvas(W,H).parent('wrapper');
  NX=NY=GRID;
  soil=[]; for(let x=0;x<GRID;x++){soil[x]=[]; for(let y=0;y<GRID;y++){soil[x][y]=new SoilCell(x,y);}}
  let _mid =Math.floor(GRID/2);
  soil[_mid ][_mid ].nest=true;
  ants=[]; 
  let mid=Math.floor(GRID/2); for(let i=0;i<count;i++) ants.push(new Ant(mid, mid));
  foods=[]; for(let i=0;i<3;i++) foods.push(new Food(random(W),random(H),100));
  nextPatch=frameCount+nutrientInterval;
}

function spawnPatch(){
  let x,y,cell;
  // ensure nutrient not on nest or tree
  do{
    x=floor(random(GRID)); y=floor(random(GRID));
    cell=soil[x][y];
  }while(cell.nest || cell.tree || cell.plant>1);
  foods.push(new Food(x*CELL+CELL/2,y*CELL+CELL/2,nutrientSize));
  for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++){
    const nx=x+dx,ny=y+dy;
    if(nx>=0&&nx<GRID&&ny>=0&&ny<GRID) soil[nx][ny].org+=nutrientSize/3;
  }
}

/* UI */
function bindUI(){
  const $=sel=>document.getElementById(sel.startsWith('#')?sel.slice(1):sel);
  $('#startBtn').onclick=()=>{running=true; loop();};
  $('#stopBtn').onclick =()=>{running=false; noLoop();};
  $('#resetBtn').onclick=()=>{initWorld(+$('#antCount').value); running=true; loop();};
  $('#antCount').oninput=e=>{const v=+e.target.value; $('#antCountLabel').textContent=v; initWorld(v);};
  $('#nutrientAmount').oninput=e=>{nutrientSize=+e.target.value; $('#nutrientAmountLabel').textContent=nutrientSize;};
  $('#nutrientInterval').oninput=e=>{nutrientInterval=+e.target.value*60; $('#nutrientIntervalLabel').textContent=e.target.value;};
}

/* P5 */
function setup(){createCanvas(10,10).parent('wrapper'); initWorld(100); bindUI();}
function draw(){
  if(!running) return;
  if(frameCount>=nextPatch){ spawnPatch(); nextPatch=frameCount+nutrientInterval; }
  soil.flat().forEach(c=>c.update());
  ants.forEach(a=>a.update());
  foods=foods.filter(f=>f.amount>0);

  background(250);
  soil.flat().forEach(c=>c.drawGround());
  stroke(204,204,204,80); strokeWeight(1);
  for(let i=0;i<=GRID;i++){ line(i*CELL,0,i*CELL,H); line(0,i*CELL,W,i*CELL); }
  foods.forEach(f=>f.draw()); ants.forEach(a=>a.draw()); soil.flat().forEach(c=>c.drawPlant());
}

window.addEventListener('resize',()=>initWorld(+document.getElementById('antCount').value));
</script>
</body>
</html>
