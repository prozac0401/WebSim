<div id="ant-n-cycle">
  <style>
    #ant-n-cycle {
      margin: 0 auto;
      padding: 10px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 900px;
      box-sizing: border-box;
      text-align: center;
    }
    #ant-n-cycle canvas {
      display: block;
      margin: 0 auto;
      background: #f8f9fa;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
      width: 100%;
      max-width: 900px;
    }
    #ant-n-cycle .controls {
      width: 100%;
      margin: 10px auto;
      text-align: center;
    }
  </style>
  <!-- Load p5.js from CDN with a local fallback -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <script>if(typeof p5==='undefined'){document.write('<script src="p5.min.js"><\\/script>');}</script>
  <!-- 설명 문구 제거 -->
  <div class="controls">
    <label>개미 수: <span id="antCountLabel">100</span></label>
    <input id="antCount" type="range" min="10" max="500" value="100" />
    <br/>
    <label>질소량: <span id="nitrogenAmountLabel">50</span></label>
    <input id="nitrogenAmount" type="range" min="10" max="500" value="50" />
    <br/>
    <label>질소 생성주기(초): <span id="nitrogenIntervalLabel">5</span></label>
    <input id="nitrogenInterval" type="range" min="1" max="20" value="5" />
  </div>
  <div id="legend" style="max-width:800px;margin:0 auto 10px auto;font-size:14px;width:100%;">
    <style>
      #legend svg{width:12px;height:12px;margin-left:10px;vertical-align:middle;}
      #legend svg:first-child{margin-left:0;}
    </style>
    <svg viewBox="0 0 12 12"><rect width="12" height="12" fill="#b5651d"/></svg>둥지
    <svg viewBox="0 0 12 12">
      <circle cx="6" cy="3" r="2" fill="#000"/>
      <circle cx="6" cy="6" r="2.5" fill="#000"/>
      <circle cx="6" cy="9" r="3" fill="#000"/>
    </svg>개미
    <svg viewBox="0 0 12 12"><circle cx="6" cy="6" r="4" fill="#ffb6c1"/></svg>사탕 부스러기
    <svg viewBox="0 0 12 12"><line x1="6" y1="10" x2="6" y2="4" stroke="brown" stroke-width="2"/><circle cx="6" cy="3" r="3" fill="green"/></svg>식물
    <svg viewBox="0 0 12 12"><rect width="12" height="12" fill="#FFFFF0" stroke="#ccc"/></svg>빈 셀
  </div>
  <div class="controls">
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
    <button id="resetBtn">Reset</button>
  </div>
  <script>
    const GRID_SIZE = 30;
    const GRID_HEIGHT = GRID_SIZE;
    let CELL_SIZE;
    let WIDTH;
    let HEIGHT;
    let NEST_X;
    let NEST_Y;
    let nitrogenAmount = 50;
    let nitrogenInterval = 5 * 60; // frames
    let nextNitrogenFrame = nitrogenInterval;

    let soil = [];
    let ants = [];
    let foodSources = [];
    let PLANT_THRESHOLD;
    let ANT_SIZE;
    const TREE_LIFESPAN = 800;
    let clusterCenters = [];

    class SoilCell {
    constructor(x, y) {
      this.x = x; this.y = y;
      this.organic = 0;
      this.nitrogen = 0;
      this.plant = 0;
      this.pheromone = 0;
      this.isNest = false;
      this.plantAge = 0;
      this.visited = false;
    }
    update() {
      let dn = this.organic * 0.02;
      this.nitrogen += dn;
      this.organic -= dn;
      let uptake = this.nitrogen * 0.01;
      this.plant += uptake*5;
      this.nitrogen -= uptake;
      // decay old plants back to nitrogen
      let decay = this.plant * 0.005;
      this.plant -= decay;
      this.nitrogen += decay;
      if(this.plant > 1){
        this.plantAge++;
        if(this.plantAge > TREE_LIFESPAN){
          this.nitrogen += this.plant;
          this.plant = 0;
          this.plantAge = 0;
        }
      } else {
        this.plantAge = 0;
      }
      this.plant = constrain(this.plant, 0, CELL_SIZE-2);
      this.pheromone *= 0.95;
      if(this.isNest && this.plant > PLANT_THRESHOLD){
        relocateNest(this);
      }
    }
    displayGround() {
      noStroke();
      let n = constrain(this.nitrogen*40, 0, 200);
      if(this.nitrogen < 0.1 && this.plant < 1 && !this.isNest){
        fill('#FFFFF0');
      }else{
        fill(220-n, 180+n/2, 120-n/3);
      }
      rect(this.x*CELL_SIZE, this.y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
      stroke('#cccccc');
      strokeWeight(1);
      noFill();
      rect(this.x*CELL_SIZE, this.y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
      noStroke();
      if(this.pheromone>0.1){
        const alpha = constrain(this.pheromone*50,0,150);
        fill(180,80,200,alpha);
        rect(this.x*CELL_SIZE, this.y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
      }
        if(this.nitrogen>0.5 && !this.isNest){
          fill('#ffb6c1');
          noStroke();
          ellipse(this.x*CELL_SIZE+CELL_SIZE/2, this.y*CELL_SIZE+CELL_SIZE/2, CELL_SIZE*0.3, CELL_SIZE*0.3);
        }
        if(this.isNest){
          fill('#b5651d');
          rect(this.x*CELL_SIZE, this.y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
      }
      displayPlant(){
        if(this.plant > 1){
          drawCherryTree(this.x, this.y, this.plant);
        }
      }
      }

    class FoodSource {
    constructor(x,y,amount){
      this.pos = createVector(x,y);
      this.amount = amount;
      this.initial = amount;
      this.shape = [];
        const steps = int(random(5,8));
        for(let i=0;i<steps;i++){
          const ang = random(TWO_PI);
          const rad = CELL_SIZE*0.8*random(1,1.8);
          this.shape.push({x:cos(ang)*rad, y:sin(ang)*rad});
        }
    }
    display(){
      if(this.amount>0){
        const frac = this.amount/this.initial;
        const c = color('#ffb6c1');
        c.setAlpha(200*frac+55);
        fill(c);
        noStroke();
        push();
        translate(this.pos.x,this.pos.y);
        beginShape();
        for(let v of this.shape){ vertex(v.x,v.y); }
        endShape(CLOSE);
        pop();
      }
    }
    }

    class Ant {
    constructor(){
      this.pos = createVector(random(width), random(height));
      this.prevPos = this.pos.copy();
      this.vel = createVector(1,0);
      this.carrying = false;
      this.isResting = false;
      this.dir = int(random(4));
      this.still = 0;
    }
    update(){
      const prev = this.pos.copy();
      if(this.isResting){
        return;
      }

      const cx = constrain(Math.floor(this.pos.x/CELL_SIZE),0,GRID_SIZE-1);
      const cy = constrain(Math.floor(this.pos.y/CELL_SIZE),0,HEIGHT/CELL_SIZE-1);
      const cell = soil[cx][cy];

      if(cell.plant > 1){
        this.pos = prev;
        this.dir = (this.dir + 2)%4;
      } else if(this.carrying){
        let nestCell = getNearestNest(this.pos);
        let target = createVector(nestCell.x*CELL_SIZE+CELL_SIZE/2,
                                 nestCell.y*CELL_SIZE+CELL_SIZE/2);
        this.pos.add(p5.Vector.sub(target,this.pos).setMag(1));
        if(p5.Vector.dist(this.pos,target)<5){
          nestCell.nitrogen += 5;
          this.carrying=false;
        }
      } else {
        let nearest = null;
        let dmin = 9999;
        for(let fs of foodSources){
          if(fs.amount>0){
            let d = p5.Vector.dist(this.pos,fs.pos);
            if(d<dmin){dmin=d; nearest=fs;}
          }
        }
        if(nearest && dmin<5){
          if(nearest.amount>0){
            nearest.amount -= 5;
            this.carrying=true;
          } else {
            this.isResting = true;
          }
        }else if(nearest && dmin<80){
          this.pos.add(p5.Vector.sub(nearest.pos,this.pos).setMag(1));
        }else if(cell.pheromone>0.1){
          let bestDir = {dx:0,dy:0,val:cell.pheromone};
          for(let dx=-1; dx<=1; dx++){
            for(let dy=-1; dy<=1; dy++){
              if(dx===0 && dy===0) continue;
              let nx=cx+dx, ny=cy+dy;
              if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<HEIGHT/CELL_SIZE){
                let pher=soil[nx][ny].pheromone;
                if(pher>bestDir.val){
                  bestDir={dx,dy,val:pher};
                }
              }
            }
          }
          this.pos.add(createVector(bestDir.dx,bestDir.dy).setMag(1));
          if(bestDir.dx==1) this.dir=1; else if(bestDir.dx==-1) this.dir=3;
          if(bestDir.dy==1) this.dir=2; else if(bestDir.dy==-1) this.dir=0;
        }else{
          if(!cell.visited){
            this.dir=(this.dir+1)%4;
            cell.visited=true;
          }else{
            this.dir=(this.dir+3)%4;
            cell.visited=false;
          }
          if(this.dir===0) this.pos.y-=1;
          if(this.dir===1) this.pos.x+=1;
          if(this.dir===2) this.pos.y+=1;
          if(this.dir===3) this.pos.x-=1;
        }
      }

      this.pos.x = constrain(this.pos.x,0,width-1);
      this.pos.y = constrain(this.pos.y,0,height-1);
      const cx2 = constrain(Math.floor(this.pos.x/CELL_SIZE),0,GRID_SIZE-1);
      const cy2 = constrain(Math.floor(this.pos.y/CELL_SIZE),0,HEIGHT/CELL_SIZE-1);
      soil[cx2][cy2].pheromone += this.carrying ? 0.5 : 0.2;
      this.vel = p5.Vector.sub(this.pos, prev);
      if(this.vel.magSq() < 0.0001) this.vel = this.vel.setMag(1);
      if(p5.Vector.dist(this.pos, prev) < 0.5){
        this.still++;
      } else {
        this.still=0;
      }
      this.prevPos = this.pos.copy();
    }
    display(){
      const col = this.carrying ? '#d020d0' : '#000';
      noStroke();
      fill(col);
      push();
      translate(this.pos.x, this.pos.y);
      rotate(this.vel.heading() + HALF_PI);
      for(let i=-1;i<=1;i+=1){
        stroke(col);
        strokeWeight(1);
        line(-ANT_SIZE*0.4,ANT_SIZE*0.1*i, -ANT_SIZE*0.8,ANT_SIZE*0.3*i);
        line(ANT_SIZE*0.4,ANT_SIZE*0.1*i, ANT_SIZE*0.8,ANT_SIZE*0.3*i);
      }
      noStroke();
      ellipse(0,-ANT_SIZE*0.3,ANT_SIZE*0.4,ANT_SIZE*0.4);
      ellipse(0,0,ANT_SIZE*0.5,ANT_SIZE*0.5);
      ellipse(0,ANT_SIZE*0.35,ANT_SIZE*0.6,ANT_SIZE*0.6);
      if(this.carrying){
        fill('#ffb6c1');
        ellipse(0,-ANT_SIZE*0.8,ANT_SIZE*0.3,ANT_SIZE*0.3);
        fill(col);
      }
      pop();
    }
    }

    function drawCherryTree(x, y, h){
      push();
      translate(x*CELL_SIZE+CELL_SIZE/2, y*CELL_SIZE+CELL_SIZE);
      stroke(139,69,19);
      strokeWeight(2);
      line(0,0,0,-h);
      noStroke();
      randomSeed(x*1000+y);
      for(let i=0;i<18;i++){
        const ang = random(TWO_PI);
        const rad = random(h*0.3, h*0.8);
        const sx = cos(ang)*rad;
        const sy = -h + sin(ang)*rad*0.5;
        const size = random(h*0.15, h*0.3);
        fill(random(['#ffc6dc','#ffd9e8','#ffeef5']));
        ellipse(sx, sy, size, size);
      }
      pop();
    }

    function drawBigCherryTree(cx, cy){
      const size = CELL_SIZE * 3;
      push();
      translate(cx*CELL_SIZE + CELL_SIZE/2, cy*CELL_SIZE + CELL_SIZE);
      stroke(139,69,19);
      strokeWeight(4);
      line(0,0,0,-size);
      noStroke();
      randomSeed(cx*2000+cy);
      for(let i=0;i<40;i++){
        const ang = random(TWO_PI);
        const rad = random(size*0.5,size*1.2);
        const sx = cos(ang)*rad;
        const sy = -size + sin(ang)*rad*0.6;
        const rsize = random(size*0.25,size*0.4);
        fill(random(['#ffc6dc','#ffd9e8','#ffeef5']));
        ellipse(sx, sy, rsize, rsize);
      }
      pop();
    }

    function computeClusterCenters(){
      clusterCenters = [];
      for(let x=1; x<GRID_SIZE-1; x++){
        for(let y=1; y<HEIGHT/CELL_SIZE-1; y++){
          let all=true;
          for(let dx=-1; dx<=1 && all; dx++){
            for(let dy=-1; dy<=1; dy++){
              if(soil[x+dx][y+dy].plant <= 1){ all=false; break; }
            }
          }
          if(all) clusterCenters.push({x,y});
        }
      }
    }

    function isPartOfCluster(x,y){
      for(let c of clusterCenters){
        if(Math.abs(c.x - x) <= 1 && Math.abs(c.y - y) <= 1) return true;
      }
      return false;
    }

    function setup(){
    const size = Math.min(window.innerWidth, 900);
    CELL_SIZE = Math.floor(size / GRID_SIZE);
    WIDTH = CELL_SIZE * GRID_SIZE;
    HEIGHT = WIDTH;
    NEST_X = Math.floor(GRID_SIZE/2);
    NEST_Y = Math.floor(GRID_HEIGHT/2);
    PLANT_THRESHOLD = CELL_SIZE/2;
    ANT_SIZE = CELL_SIZE * 0.4;
    let canvas = createCanvas(WIDTH, HEIGHT);
    canvas.id('canvas');
    for(let x=0;x<GRID_SIZE;x++){
      soil[x]=[];
      for(let y=0;y<HEIGHT/CELL_SIZE;y++){
        soil[x][y]=new SoilCell(x,y);
      }
    }
    soil[NEST_X][NEST_Y].isNest = true;
    initFood();
    initAnts(100);
    document.getElementById('antCount').addEventListener('input', e=>{
      const val = parseInt(e.target.value);
      document.getElementById('antCountLabel').textContent = val;
      initAnts(val);
    });
    }

    function draw(){
    background(250);
    if(frameCount>=nextNitrogenFrame){
      spawnNitrogenPatch();
      nextNitrogenFrame = frameCount + nitrogenInterval;
    }
    for(let x=0;x<GRID_SIZE;x++){
      for(let y=0;y<HEIGHT/CELL_SIZE;y++){
        soil[x][y].update();
        soil[x][y].displayGround();
      }
    }
    for(let fs of foodSources){fs.display();}
    for(let ant of ants){
      ant.update();
      ant.display();
    }
    computeClusterCenters();
    for(let c of clusterCenters){
      drawBigCherryTree(c.x,c.y);
    }
    for(let x=0;x<GRID_SIZE;x++){
      for(let y=0;y<HEIGHT/CELL_SIZE;y++){
        if(!isPartOfCluster(x,y)) soil[x][y].displayPlant();
      }
    }

    }

    function initFood(){
    foodSources=[];
    for(let i=0;i<3;i++){
      foodSources.push(new FoodSource(random(width), random(height), 100));
    }
    }

function initAnts(n){
  ants=[];
  for(let i=0;i<n;i++) ants.push(new Ant());
}

function relocateNest(cell){
  cell.isNest = false;
  let best = null;
  let bestNitrogen = -1;
  for(let i=0;i<50;i++){
    const x = Math.floor(random(GRID_SIZE));
    const y = Math.floor(random(HEIGHT/CELL_SIZE));
    const c = soil[x][y];
    if(!c.isNest && c.plant < 1){
    if(c.nitrogen > bestNitrogen){
      bestNitrogen = c.nitrogen;
      best = c;
    }
    }
  }
  if(!best){
    best = soil[Math.floor(random(GRID_SIZE))][Math.floor(random(HEIGHT/CELL_SIZE))];
  }
  best.isNest = true;
}

    function getNearestNest(pos){
    let nearest=null;
    let dmin=9999;
    for(let x=0;x<GRID_SIZE;x++){
      for(let y=0;y<HEIGHT/CELL_SIZE;y++){
        if(soil[x][y].isNest){
          let c = createVector(x*CELL_SIZE+CELL_SIZE/2,y*CELL_SIZE+CELL_SIZE/2);
          let d=p5.Vector.dist(pos,c);
          if(d<dmin){dmin=d; nearest=soil[x][y];}
        }
      }
    }
    return nearest||soil[NEST_X][NEST_Y];
    }

    function spawnNitrogenPatch(){
  const cx = Math.floor(random(GRID_SIZE));
  const cy = Math.floor(random(HEIGHT/CELL_SIZE));
  foodSources.push(new FoodSource(cx*CELL_SIZE+CELL_SIZE/2, cy*CELL_SIZE+CELL_SIZE/2, nitrogenAmount));

  for(let ant of ants){
    ant.isResting = false;
  }

    for(let dx=-1; dx<=1; dx++){
      for(let dy=-1; dy<=1; dy++){
        let nx=cx+dx, ny=cy+dy;
        if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<HEIGHT/CELL_SIZE){
          soil[nx][ny].nitrogen += nitrogenAmount/3;
        }
      }
    }
    }

    function mousePressed(){
    if(mouseX>=0 && mouseX<width && mouseY>=0 && mouseY<height){
      const cx = Math.floor(mouseX/CELL_SIZE);
      const cy = Math.floor(mouseY/CELL_SIZE);
      soil[cx][cy].isNest = !soil[cx][cy].isNest;
    }
    }

    document.getElementById('nitrogenAmount').addEventListener('input', e=>{
    nitrogenAmount = parseInt(e.target.value);
    document.getElementById('nitrogenAmountLabel').textContent = nitrogenAmount;
    });
    document.getElementById('nitrogenInterval').addEventListener('input', e=>{
    const val = parseInt(e.target.value);
    document.getElementById('nitrogenIntervalLabel').textContent = val;
    nitrogenInterval = val*60;
    });
    document.getElementById('startBtn').addEventListener('click',()=>loop());
    document.getElementById('stopBtn').addEventListener('click',()=>noLoop());
    document.getElementById('resetBtn').addEventListener('click',()=>{
      initFood();
      initAnts(parseInt(document.getElementById('antCount').value));
      for(let x=0;x<GRID_SIZE;x++){
        for(let y=0;y<HEIGHT/CELL_SIZE;y++){
          soil[x][y].organic=0;
          soil[x][y].nitrogen=0;
          soil[x][y].plant=0;
          soil[x][y].plantAge=0;
          soil[x][y].pheromone=0;
          soil[x][y].isNest=false;
        }
      }
      soil[NEST_X][NEST_Y].isNest=true;
      loop();
    });
  </script>
</div>
