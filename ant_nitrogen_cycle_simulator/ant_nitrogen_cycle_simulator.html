<div id="ant-n-cycle">
  <style>
    #ant-n-cycle {
      margin: 0 auto;
      padding: 10px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 900px;
      box-sizing: border-box;
      text-align: center;
    }
    #ant-n-cycle canvas {
      display: block;
      margin: 0 auto;
      background: #f8f9fa;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
      width: 100%;
      max-width: 900px;
    }
    #ant-n-cycle .controls {
      width: 100%;
      margin: 10px auto;
      text-align: center;
    }
  </style>
  <!-- Load p5.js from CDN with a local fallback -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <script>if(typeof p5==='undefined'){document.write('<script src="p5.min.js"><\\/script>');}</script>
  <!-- 설명 문구 제거 -->
  <div class="controls">
    <label>개미 수: <span id="antCountLabel">100</span></label>
    <input id="antCount" type="range" min="10" max="500" value="100" />
    <br/>
    <label>질소량: <span id="nitrogenAmountLabel">50</span></label>
    <input id="nitrogenAmount" type="range" min="10" max="500" value="50" />
    <br/>
    <label>질소 생성주기(초): <span id="nitrogenIntervalLabel">5</span></label>
    <input id="nitrogenInterval" type="range" min="1" max="20" value="5" />
  </div>
  <div id="legend" style="max-width:800px;margin:0 auto 10px auto;font-size:14px;width:100%;">
    <style>
      #legend svg{width:12px;height:12px;margin-left:10px;vertical-align:middle;}
      #legend svg:first-child{margin-left:0;}
    </style>
    <svg viewBox="0 0 12 12"><rect width="12" height="12" fill="#b5651d"/></svg>둥지
    <svg viewBox="0 0 12 12">
      <circle cx="6" cy="3" r="2" fill="#000"/>
      <circle cx="6" cy="6" r="2.5" fill="#000"/>
      <circle cx="6" cy="9" r="3" fill="#000"/>
    </svg>개미
    <svg viewBox="0 0 12 12"><circle cx="6" cy="6" r="4" fill="#ffb6c1"/></svg>사탕 부스러기
    <svg viewBox="0 0 12 12"><line x1="6" y1="10" x2="6" y2="4" stroke="brown" stroke-width="2"/><circle cx="6" cy="3" r="3" fill="green"/></svg>식물
    <svg viewBox="0 0 12 12"><rect width="12" height="12" fill="#FFFFF0" stroke="#ccc"/></svg>빈 셀
  </div>
  <div class="controls">
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
    <button id="resetBtn">Reset</button>
  </div>
  <script>
    const GRID_SIZE = 30;
    const GRID_HEIGHT = GRID_SIZE;
    const MAX_NESTS = 6;
    let CELL_SIZE;
    let WIDTH;
    let HEIGHT;
    let NEST_X;
    let NEST_Y;
    let nitrogenAmount = 50;
    let nitrogenInterval = 5 * 60; // frames
    let nextNitrogenFrame = nitrogenInterval;

    let soil = [];
    let ants = [];
    let foodSources = [];
    let PLANT_THRESHOLD;
    let ANT_SIZE;
    let ANT_SPEED = 1.5;
    const TREE_LIFESPAN = 800;
    const STILL_LIMIT = 600; // frames before an unmoving ant is removed
    const MIN_CLUSTER_SIZE = 5; // cells needed to form a big tree
    const SHADE_MAX_NITROGEN = 5; // nitrogen value mapped to darkest shade
    let nestCount = 0;
    let clusterCenters = [];
    let clusterCells = [];
    let clusterMap = [];
    let flowPath = [];

    function mulberry32(a){
      return function(){
        var t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
    }

    class SoilCell {
    constructor(x, y) {
      this.x = x; this.y = y;
      this.organic = 0;
      this.nitrogen = 0;
      this.plant = 0;
      this.pheromone = 0;
      this.isNest = false;
      this.plantAge = 0;
      this.visited = false;
      this.treeSpawned = false;
    }
    update() {
      let dn = this.organic * 0.02;
      this.nitrogen += dn;
      this.organic -= dn;
      let uptake = this.nitrogen * 0.01;
      this.plant += uptake*5;
      this.nitrogen -= uptake;
      // decay old plants back to nitrogen
      let decay = this.plant * 0.005;
      this.plant -= decay;
      this.nitrogen += decay;
      if(this.plant > 1){
        if(!this.treeSpawned && !this.isNest && !isNestNearby(this.x, this.y, 3)){
          spawnNestNear(this.x, this.y);
          this.treeSpawned = true;
        }
        this.plantAge++;
        if(this.plantAge === 1){
          for(let ant of ants){ ant.isResting = false; }
        }
        if(this.plantAge > TREE_LIFESPAN){
          this.nitrogen += this.plant;
          this.plant = 0;
          this.plantAge = 0;
        }
      } else {
        this.plantAge = 0;
      }
      this.plant = constrain(this.plant, 0, CELL_SIZE-2);
      this.pheromone *= 0.95;
      if(this.isNest && this.plant > PLANT_THRESHOLD){
        relocateNest(this);
      }
    }
      displayGround() {
        noStroke();
        let n = constrain(this.nitrogen * 40, 0, 200);
        if(this.nitrogen < 0.1 && this.plant < 1 && !this.isNest){
          fill('#FFFFF0');
          const shade = 230 - n;
          fill(shade);
        } else {
        }
        rect(this.x*CELL_SIZE, this.y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
        stroke('#cccccc');
        strokeWeight(1);
        noFill();
        rect(this.x*CELL_SIZE, this.y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
        noStroke();
      if(this.pheromone>0.1){
        const alpha = constrain(this.pheromone*50,0,150);
        fill(180,80,200,alpha);
        rect(this.x*CELL_SIZE, this.y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
      }
      if(this.nitrogen>0.5 && !this.isNest && this.plant <= 1){
          fill('#ffb6c1');
          noStroke();
          ellipse(this.x*CELL_SIZE+CELL_SIZE/2, this.y*CELL_SIZE+CELL_SIZE/2, CELL_SIZE*0.3, CELL_SIZE*0.3);
        }
        if(this.isNest){
          fill('#b5651d');
          rect(this.x*CELL_SIZE, this.y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
      }
      displayNitrogenFlow(){
        if(this.isNest || this.plant>1) return;
        textAlign(CENTER, CENTER);
        textSize(CELL_SIZE*0.5);
        noStroke();
        const dirs=[
          {dx:0,dy:-1,ch:'▼'}, // from cell above to here
          {dx:1,dy:0,ch:'◀'},  // from cell to the right
          {dx:0,dy:1,ch:'▲'},  // from cell below
          {dx:-1,dy:0,ch:'▶'}  // from cell to the left
        ];
        let bestDiff=0;
        let arrow=null;
        for(let d of dirs){
          const nx=this.x+d.dx;
          const ny=this.y+d.dy;
          if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<HEIGHT/CELL_SIZE){
            const diff=soil[nx][ny].nitrogen-this.nitrogen;
            if(diff>0.05 && diff>bestDiff){
              bestDiff=diff;
              arrow=d.ch;
            }
          }
        }
        if(arrow){
          const c=color('#ff9900');
          c.setAlpha(constrain(bestDiff*80,50,200));
          fill(c);
          text(arrow, this.x*CELL_SIZE+CELL_SIZE/2, this.y*CELL_SIZE+CELL_SIZE/2);
        }
      }
      displayNitrogenLevel(){
        textAlign(CENTER,CENTER);
        textSize(CELL_SIZE*0.3);
        noStroke();
        fill('#003300');
        text(this.nitrogen.toFixed(1), this.x*CELL_SIZE+CELL_SIZE/2, this.y*CELL_SIZE+CELL_SIZE/2);
      }
      displayPlant(){
        if(this.plant > 1){
          drawCherryTree(this.x, this.y, this.plant);
        }
      }
      }

    class FoodSource {
    constructor(x,y,amount){
      this.pos = createVector(x,y);
      this.amount = amount;
      this.initial = amount;
      this.shape = [];
      const steps = 8;
      for(let i=0;i<steps;i++){
        const ang = TWO_PI*i/steps + random(-0.2,0.2);
        const rad = CELL_SIZE*0.8*random(0.8,1.2);
        this.shape.push({x:cos(ang)*rad, y:sin(ang)*rad});
      }
    }
    display(){
      if(this.amount>0){
        const frac = this.amount/this.initial;
        const step = Math.ceil(frac*5)/5;
        const c = color('#ffb6c1');
        c.setAlpha(200*step+55);
        fill(c);
        stroke(255,255,255,180*step);
        strokeWeight(1);
        push();
        translate(this.pos.x,this.pos.y);
        beginShape();
        for(let v of this.shape){ vertex(v.x*step,v.y*step); }
        endShape(CLOSE);
        noStroke();
        fill(255,255,255,150*step);
        ellipse(0,-CELL_SIZE*0.2*step,CELL_SIZE*0.3*step,CELL_SIZE*0.2*step);
        pop();
      }
    }
    }

    class Ant {
    constructor(){
      this.pos = createVector(random(width), random(height));
      this.prevPos = this.pos.copy();
      this.vel = createVector(1,0);
      this.carrying = false;
      this.isResting = false;
      this.dir = int(random(4));
      this.still = 0;
    }
    update(){
      const prev = this.pos.copy();
      const cx = constrain(Math.floor(this.pos.x/CELL_SIZE),0,GRID_SIZE-1);
      const cy = constrain(Math.floor(this.pos.y/CELL_SIZE),0,HEIGHT/CELL_SIZE-1);
      const cell = soil[cx][cy];

      if(this.isResting){
        let awakened = cell.pheromone > 0.1;
        for(let dx=-1; dx<=1 && !awakened; dx++){
          for(let dy=-1; dy<=1 && !awakened; dy++){
            if(dx===0 && dy===0) continue;
            let nx=cx+dx, ny=cy+dy;
            if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<HEIGHT/CELL_SIZE){
              if(soil[nx][ny].pheromone > 0.1){
                this.pos.add(createVector(dx,dy).setMag(ANT_SPEED));
                this.dir = dx==1?1:dx==-1?3:dy==1?2:0;
                awakened = true;
              }
            }
          }
        }
        if(!awakened){
          return;
        }
        this.isResting=false;
      }

      if(cell.plant > 1){
        this.pos = prev;
        this.dir = (this.dir + 2)%4;
      } else if(this.carrying){
        let nestCell = getNearestNest(this.pos);
        let target = createVector(nestCell.x*CELL_SIZE+CELL_SIZE/2,
                                 nestCell.y*CELL_SIZE+CELL_SIZE/2);
        this.pos.add(p5.Vector.sub(target,this.pos).setMag(ANT_SPEED));
        if(p5.Vector.dist(this.pos,target)<5){
          nestCell.nitrogen += 5;
          this.carrying=false;
        }
      } else {
        let nearest = null;
        let dmin = 9999;
        for(let fs of foodSources){
          if(fs.amount>0){
            let d = p5.Vector.dist(this.pos,fs.pos);
            if(d<dmin){dmin=d; nearest=fs;}
          }
        }
        if(nearest && dmin<5){
          if(nearest.amount>0){
            nearest.amount -= 5;
            this.carrying=true;
          } else {
            this.isResting = true;
          }
        }else if(nearest && dmin<80){
          this.pos.add(p5.Vector.sub(nearest.pos,this.pos).setMag(ANT_SPEED));
        }else if(cell.pheromone>0.1){
          let bestDir = {dx:0,dy:0,val:cell.pheromone};
          for(let dx=-1; dx<=1; dx++){
            for(let dy=-1; dy<=1; dy++){
              if(dx===0 && dy===0) continue;
              let nx=cx+dx, ny=cy+dy;
              if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<HEIGHT/CELL_SIZE){
                let pher=soil[nx][ny].pheromone;
                if(pher>bestDir.val){
                  bestDir={dx,dy,val:pher};
                }
              }
            }
          }
          if(bestDir.dx===0 && bestDir.dy===0){
            const randDir = int(random(4));
            if(randDir===0) this.pos.y-=ANT_SPEED;
            if(randDir===1) this.pos.x+=ANT_SPEED;
            if(randDir===2) this.pos.y+=ANT_SPEED;
            if(randDir===3) this.pos.x-=ANT_SPEED;
            this.dir = randDir;
          }else{
            this.pos.add(createVector(bestDir.dx,bestDir.dy).setMag(ANT_SPEED));
            if(bestDir.dx==1) this.dir=1; else if(bestDir.dx==-1) this.dir=3;
            if(bestDir.dy==1) this.dir=2; else if(bestDir.dy==-1) this.dir=0;
          }
        }else{
          if(!cell.visited){
            this.dir=(this.dir+1)%4;
            cell.visited=true;
          }else{
            this.dir=(this.dir+3)%4;
            cell.visited=false;
          }
          if(this.dir===0) this.pos.y-=ANT_SPEED;
          if(this.dir===1) this.pos.x+=ANT_SPEED;
          if(this.dir===2) this.pos.y+=ANT_SPEED;
          if(this.dir===3) this.pos.x-=ANT_SPEED;
        }
      }

      this.pos.x = constrain(this.pos.x,0,width-1);
      this.pos.y = constrain(this.pos.y,0,height-1);
      const cx2 = constrain(Math.floor(this.pos.x/CELL_SIZE),0,GRID_SIZE-1);
      const cy2 = constrain(Math.floor(this.pos.y/CELL_SIZE),0,HEIGHT/CELL_SIZE-1);
      soil[cx2][cy2].pheromone += this.carrying ? 0.5 : 0.2;
      this.vel = p5.Vector.sub(this.pos, prev);
      if(this.vel.magSq() < 0.0001) this.vel = this.vel.setMag(ANT_SPEED);
      if(p5.Vector.dist(this.pos, prev) < 0.5){
        this.still++;
      } else {
        this.still=0;
      }
      if(this.still > STILL_LIMIT){
        this.dead = true;
      }
      this.prevPos = this.pos.copy();
    }
    display(){
      const col = this.carrying ? '#d020d0' : '#000';
      noStroke();
      fill(col);
      push();
      translate(this.pos.x, this.pos.y);
      rotate(this.vel.heading() + HALF_PI);
      for(let i=-1;i<=1;i+=1){
        stroke(col);
        strokeWeight(1);
        line(-ANT_SIZE*0.4,ANT_SIZE*0.1*i, -ANT_SIZE*0.8,ANT_SIZE*0.3*i);
        line(ANT_SIZE*0.4,ANT_SIZE*0.1*i, ANT_SIZE*0.8,ANT_SIZE*0.3*i);
      }
      noStroke();
      ellipse(0,-ANT_SIZE*0.3,ANT_SIZE*0.4,ANT_SIZE*0.4);
      ellipse(0,0,ANT_SIZE*0.5,ANT_SIZE*0.5);
      ellipse(0,ANT_SIZE*0.35,ANT_SIZE*0.6,ANT_SIZE*0.6);
      if(this.carrying){
        fill('#ffb6c1');
        ellipse(0,-ANT_SIZE*0.8,ANT_SIZE*0.3,ANT_SIZE*0.3);
        fill(col);
      }
      pop();
    }
    }

    function drawCherryTree(x, y, h){
      push();
      translate(x*CELL_SIZE+CELL_SIZE/2, y*CELL_SIZE+CELL_SIZE);
      stroke(139,69,19);
      strokeWeight(6);
      line(0,0,0,-h);
      noStroke();
      const rng = mulberry32(x*1000+y);
      for(let i=0;i<20;i++){ 
        const ang = rng()*TWO_PI; 
        const rad = rng()*(h*0.6) + h*0.2; 
        const sx = cos(ang)*rad;
        const sy = -h + sin(ang)*rad*0.5;
        const size = rng()*(h*0.15) + h*0.15;
        const colors = ['#ffc6dc','#ffd9e8','#ffeef5'];
        const col = colors[Math.floor(rng()*colors.length)];
        stroke(col);
        strokeWeight(1);
        noFill();
        drawSnowflakePetal(sx, sy, size);
      }
      pop();
    }

      function drawBigCherryTree(cx, cy){
        const size = CELL_SIZE * 3;
        push();
        translate(cx*CELL_SIZE + CELL_SIZE/2, cy*CELL_SIZE + CELL_SIZE);
        stroke(139,69,19);
        strokeWeight(8);
        line(0,0,0,-size);
        noStroke();
        const rng = mulberry32(cx*2000+cy);
        for(let i=0;i<50;i++){
          const ang = rng()*TWO_PI;
          const rad = rng()*size*0.8 + size*0.2;
          const sx = cos(ang)*rad;
          const sy = -size + sin(ang)*rad*0.6;
          const rsize = rng()*size*0.15 + size*0.25;
          const colors = ['#ffc6dc','#ffd9e8','#ffeef5'];
          const col = colors[Math.floor(rng()*colors.length)];
          fill(col);
          drawFullBloom(sx, sy, rsize);
        }
        pop();
      }

      function drawSnowflakePetal(px, py, size){
        push();
        translate(px, py);
        noStroke();
        const petals = 6;
        for(let i=0;i<petals;i++){
          const ang = TWO_PI*i/petals;
          const x = cos(ang)*size*0.25;
          const y = sin(ang)*size*0.25;
          ellipse(x, y, size*0.4, size*0.4);
        }
        pop();
      }

      function drawFullBloom(px, py, size){
        push();
        translate(px, py);
        noStroke();
        const petals = 6;
        for(let i=0;i<petals;i++){
          const ang = TWO_PI*i/petals;
          const x = cos(ang)*size*0.4;
          const y = sin(ang)*size*0.4;
          ellipse(x, y, size*0.7, size*0.7);
        }
        pop();
      }

function computeClusterCenters(){
      clusterCenters = [];
      clusterCells = [];
      clusterMap = Array.from({length: GRID_SIZE}, () =>
        Array(HEIGHT/CELL_SIZE).fill(false));
      const visited = Array.from({length: GRID_SIZE}, () =>
        Array(HEIGHT/CELL_SIZE).fill(false));
      for(let x=0; x<GRID_SIZE; x++){
        for(let y=0; y<HEIGHT/CELL_SIZE; y++){
          if(visited[x][y] || soil[x][y].plant <= 1) continue;
          const queue = [[x,y]];
          visited[x][y] = true;
          let sumX = 0, sumY = 0, count = 0;
          const cells = [];
          while(queue.length){
            const [cx,cy] = queue.pop();
            sumX += cx; sumY += cy; count++;
            cells.push({x:cx,y:cy});
            for(let dx=-1; dx<=1; dx++){
              for(let dy=-1; dy<=1; dy++){
                if(dx===0 && dy===0) continue;
                let nx=cx+dx, ny=cy+dy;
                if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<HEIGHT/CELL_SIZE &&
                   !visited[nx][ny] && soil[nx][ny].plant > 1){
                  visited[nx][ny] = true;
                  queue.push([nx,ny]);
                }
              }
            }
          }
          if(count >= MIN_CLUSTER_SIZE){
            let cx = Math.floor(sumX / count);
            let cy = Math.floor(sumY / count);
            cx = constrain(cx, 0, GRID_SIZE - 1);
            cy = constrain(cy, 0, HEIGHT / CELL_SIZE - 1);
            clusterCenters.push({x: cx, y: cy});
            for(let c of cells){
              clusterCells.push(c);
              clusterMap[c.x][c.y] = true;
            }
          }
        }
      }
    }

    function isPartOfCluster(x,y){
      return clusterMap[x] && clusterMap[x][y];
    }

    function setup(){
    console.log('setup called');
    const size = Math.min(window.innerWidth, 900);
    CELL_SIZE = Math.floor(size / GRID_SIZE);
    WIDTH = CELL_SIZE * GRID_SIZE;
    HEIGHT = WIDTH;
    NEST_X = Math.floor(GRID_SIZE/2);
    NEST_Y = Math.floor(GRID_HEIGHT/2);
    PLANT_THRESHOLD = CELL_SIZE/2;
    ANT_SIZE = CELL_SIZE * 0.4;
    ANT_SPEED = CELL_SIZE * 0.1;
    let canvas = createCanvas(WIDTH, HEIGHT);
    canvas.id('canvas');
    for(let x=0;x<GRID_SIZE;x++){
      soil[x]=[];
      for(let y=0;y<HEIGHT/CELL_SIZE;y++){
        soil[x][y]=new SoilCell(x,y);
      }
    }
    soil[NEST_X][NEST_Y].isNest = true;
    soil[NEST_X][NEST_Y].treeSpawned = true;
    nestCount = 1;
    initFood();
    initAnts(100);
    document.getElementById('antCount').addEventListener('input', e=>{
      const val = parseInt(e.target.value);
      document.getElementById('antCountLabel').textContent = val;
      initAnts(val);
    });
    }

    function draw(){
    background(250);
    if(frameCount>=nextNitrogenFrame){
      spawnNitrogenPatch();
      nextNitrogenFrame = frameCount + nitrogenInterval;
    }
    for(let x=0;x<GRID_SIZE;x++){
      for(let y=0;y<HEIGHT/CELL_SIZE;y++){
        soil[x][y].update();
        soil[x][y].displayGround();
        //soil[x][y].displayNitrogenFlow();
        if(soil[x][y].plantAge === 1){
          releaseTrappedAnts(NEST_X, NEST_Y);
        }
      }
    }
  for(let fs of foodSources){fs.display();}
  updateFoodSources();
  for(let ant of ants){
    ant.update();
    ant.display();
  }
    ants = ants.filter(a => !a.dead);
    if(frameCount % 300 === 0){
      // Periodically free ants trapped in trees so they don't hit STILL_LIMIT
      releaseTrappedAnts(NEST_X, NEST_Y);
    }
    computeClusterCenters();
    computeFlowPath();
      for(let c of clusterCenters){
        drawBigCherryTree(c.x,c.y);
      }
      for(let x=0;x<GRID_SIZE;x++){
        for(let y=0;y<HEIGHT/CELL_SIZE;y++){
          if(!isPartOfCluster(x,y)) soil[x][y].displayPlant();
        }
      }
    displayClusterOverlay();
    drawFlowPath();

      // draw nitrogen arrows on top of trees and plants so flow remains visible
      for(let x=0;x<GRID_SIZE;x++){
        for(let y=0;y<HEIGHT/CELL_SIZE;y++){
          //soil[x][y].displayNitrogenFlow();
          soil[x][y].displayGround();
        }
      }

    }

    function initFood(){
    foodSources=[];
    for(let i=0;i<3;i++){
      foodSources.push(new FoodSource(random(width), random(height), 100));
    }
    }

function initAnts(n){
  ants=[];
  for(let i=0;i<n;i++) ants.push(new Ant());
}

function relocateNest(cell){
  cell.isNest = false;
  let best = null;
  let bestNitrogen = -1;
  for(let i=0;i<50;i++){
    const x = Math.floor(random(GRID_SIZE));
    const y = Math.floor(random(HEIGHT/CELL_SIZE));
    const c = soil[x][y];
    if(!c.isNest && c.plant < 1){
    if(c.nitrogen > bestNitrogen){
      bestNitrogen = c.nitrogen;
      best = c;
    }
    }
  }
  if(!best){
    best = soil[Math.floor(random(GRID_SIZE))][Math.floor(random(HEIGHT/CELL_SIZE))];
  }
  best.isNest = true;
}

function spawnNestNear(cx, cy){
  if(nestCount >= MAX_NESTS) return;
  let options=[];
  for(let dx=-1; dx<=1; dx++){
    for(let dy=-1; dy<=1; dy++){
      if(dx===0 && dy===0) continue;
      let nx=cx+dx, ny=cy+dy;
      if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<HEIGHT/CELL_SIZE){
        let cell=soil[nx][ny];
        if(!cell.isNest && cell.plant<=1){
          options.push(cell);
        }
      }
    }
  }
  if(options.length>0){
    const nestCell = random(options);
    nestCell.isNest = true;
    nestCount++;
    nestCell.treeSpawned = true;
    for(let ant of ants){
      const ax=Math.floor(ant.pos.x/CELL_SIZE);
      const ay=Math.floor(ant.pos.y/CELL_SIZE);
      if(ax===cx && ay===cy){
        ant.pos.x = nestCell.x*CELL_SIZE + CELL_SIZE/2;
        ant.pos.y = nestCell.y*CELL_SIZE + CELL_SIZE/2;
        ant.prevPos = ant.pos.copy();
        ant.isResting=false;
      }
    }
    // spawnNitrogenPatchAround(nestCell.x, nestCell.y);
  }
}

function isNestNearby(x, y, radius){
  for(let dx=-radius; dx<=radius; dx++){
    for(let dy=-radius; dy<=radius; dy++){
      if(dx===0 && dy===0) continue;
      let nx = x + dx, ny = y + dy;
      if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<HEIGHT/CELL_SIZE){
        if(soil[nx][ny].isNest){
          return true;
        }
      }
    }
  }
  return false;
}

    function getNearestNest(pos){
    let nearest=null;
    let dmin=9999;
    for(let x=0;x<GRID_SIZE;x++){
      for(let y=0;y<HEIGHT/CELL_SIZE;y++){
        if(soil[x][y].isNest){
          let c = createVector(x*CELL_SIZE+CELL_SIZE/2,y*CELL_SIZE+CELL_SIZE/2);
          let d=p5.Vector.dist(pos,c);
          if(d<dmin){dmin=d; nearest=soil[x][y];}
        }
      }
    }
    return nearest||soil[NEST_X][NEST_Y];
    }

function releaseTrappedAnts(tx, ty){
  for(let ant of ants){
    const ax = Math.floor(ant.pos.x/CELL_SIZE);
    const ay = Math.floor(ant.pos.y/CELL_SIZE);
    if(soil[ax][ay].plant > 1){
      ant.pos.x = tx*CELL_SIZE + CELL_SIZE/2;
      ant.pos.y = ty*CELL_SIZE + CELL_SIZE/2;
      ant.prevPos = ant.pos.copy();
      ant.isResting = false;
      ant.still = 0;
    }
  }
}

function spawnNitrogenPatch(){
  let cx, cy;
  do {
    cx = Math.floor(random(GRID_SIZE));
    cy = Math.floor(random(HEIGHT/CELL_SIZE));
  } while(soil[cx][cy].plant > 1);
  foodSources.push(new FoodSource(cx*CELL_SIZE+CELL_SIZE/2, cy*CELL_SIZE+CELL_SIZE/2, nitrogenAmount));
  releaseTrappedAnts(cx, cy);

  for(let ant of ants){
    ant.isResting = false;
    ant.still = 0;
  }

    for(let dx=-1; dx<=1; dx++){
      for(let dy=-1; dy<=1; dy++){
        let nx=cx+dx, ny=cy+dy;
        if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<HEIGHT/CELL_SIZE){
          soil[nx][ny].nitrogen += nitrogenAmount/3;
        }
    }
  }
}

function spawnNitrogenPatchAround(cx, cy){
  let options=[];
  for(let dx=-2; dx<=2; dx++){
    for(let dy=-2; dy<=2; dy++){
      let nx=cx+dx, ny=cy+dy;
      if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<HEIGHT/CELL_SIZE){
        let cell=soil[nx][ny];
        if(cell.plant<=1){
          options.push({x:nx,y:ny});
        }
      }
    }
  }
  if(options.length>0){
    const choice = random(options);
    foodSources.push(new FoodSource(choice.x*CELL_SIZE+CELL_SIZE/2, choice.y*CELL_SIZE+CELL_SIZE/2, nitrogenAmount));
    releaseTrappedAnts(choice.x, choice.y);
    for(let ant of ants){
      ant.isResting=false;
      ant.still = 0;
    }
    for(let dx=-1; dx<=1; dx++){
      for(let dy=-1; dy<=1; dy++){
        let nx=choice.x+dx, ny=choice.y+dy;
        if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<HEIGHT/CELL_SIZE){
          soil[nx][ny].nitrogen += nitrogenAmount/3;
        }
      }
    }
  }
}

function computeFlowPath(){
  flowPath = [];
  const DIRS = [
    {dx:0,dy:-1,ch:'▲'},
    {dx:1,dy:0,ch:'▶'},
    {dx:0,dy:1,ch:'▼'},
    {dx:-1,dy:0,ch:'◀'}
  ];
  let cx = NEST_X;
  let cy = NEST_Y;
  const visited = new Set([cx+','+cy]);
  for(let i=0;i<GRID_SIZE*2;i++){
    let best = null;
    let bestVal = soil[cx][cy].plant*2 + soil[cx][cy].nitrogen;
    let bestDir = null;
    for(let d of DIRS){
      const nx=cx+d.dx, ny=cy+d.dy;
      if(nx>=0 && nx<GRID_SIZE && ny>=0 && ny<HEIGHT/CELL_SIZE && !visited.has(nx+','+ny)){
        const cell=soil[nx][ny];
        const val=cell.plant*2 + cell.nitrogen;
        if(val>bestVal){
          bestVal=val;
          best={x:nx,y:ny};
          bestDir=d.ch;
        }
      }
    }
    if(!best) break;
    flowPath.push({x:cx,y:cy,ch:bestDir});
    cx=best.x; cy=best.y;
    visited.add(cx+','+cy);
    if(soil[cx][cy].plant>1) break;
  }
}

function drawFlowPath(){
  textAlign(CENTER,CENTER);
  textSize(CELL_SIZE*0.6);
  noStroke();
  fill('#ff6600');
  for(let step of flowPath){
    text(step.ch, step.x*CELL_SIZE+CELL_SIZE/2, step.y*CELL_SIZE+CELL_SIZE/2);
  }
}

function displayClusterOverlay(){
  noFill();
  stroke('#1e90ff');
  strokeWeight(1);
  for(let c of clusterCells){
    rect(c.x*CELL_SIZE, c.y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
  }
}

function updateFoodSources(){
  for(let i=foodSources.length-1;i>=0;i--){
    const fs = foodSources[i];
    const cx = Math.floor(fs.pos.x / CELL_SIZE);
    const cy = Math.floor(fs.pos.y / CELL_SIZE);
    if(fs.amount <= 0 || soil[cx][cy].plant > 1){
      foodSources.splice(i,1);
    }
  }
}

    function mousePressed(){
    if(mouseX>=0 && mouseX<width && mouseY>=0 && mouseY<height){
      const cx = Math.floor(mouseX/CELL_SIZE);
      const cy = Math.floor(mouseY/CELL_SIZE);
      soil[cx][cy].isNest = !soil[cx][cy].isNest;
    }
    }

    document.getElementById('nitrogenAmount').addEventListener('input', e=>{
    nitrogenAmount = parseInt(e.target.value);
    document.getElementById('nitrogenAmountLabel').textContent = nitrogenAmount;
    });
    document.getElementById('nitrogenInterval').addEventListener('input', e=>{
    const val = parseInt(e.target.value);
    document.getElementById('nitrogenIntervalLabel').textContent = val;
    nitrogenInterval = val*60;
    });
    document.getElementById('startBtn').addEventListener('click',()=>loop());
    document.getElementById('stopBtn').addEventListener('click',()=>noLoop());
    document.getElementById('resetBtn').addEventListener('click',()=>{
      initFood();
      initAnts(parseInt(document.getElementById('antCount').value));
      for(let x=0;x<GRID_SIZE;x++){
        for(let y=0;y<HEIGHT/CELL_SIZE;y++){
          soil[x][y].organic=0;
          soil[x][y].nitrogen=0;
          soil[x][y].plant=0;
          soil[x][y].plantAge=0;
          soil[x][y].pheromone=0;
          soil[x][y].isNest=false;
          soil[x][y].treeSpawned=false;
        }
      }
      soil[NEST_X][NEST_Y].isNest=true;
      soil[NEST_X][NEST_Y].treeSpawned=true;
      nestCount = 1;
      loop();
    });
    console.log('setup type before new p5', typeof window.setup);
    new p5();
  </script>
</div>
